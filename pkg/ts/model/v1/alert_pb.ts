// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file model/v1/alert.proto (package model.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum model.v1.AlertType
 */
export enum AlertType {
  /**
   * @generated from enum value: UNKNOWN_ALERT_TYPE = 0;
   */
  UNKNOWN_ALERT_TYPE = 0,

  /**
   * @generated from enum value: TRANSACTION = 1;
   */
  TRANSACTION = 1,

  /**
   * @generated from enum value: BLOCK = 2;
   */
  BLOCK = 2,

  /**
   * @generated from enum value: PRIVATE = 3;
   */
  PRIVATE = 3,

  /**
   * @generated from enum value: COMBINATION = 4;
   */
  COMBINATION = 4,

  /**
   * @generated from enum value: API = 5;
   */
  API = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(AlertType)
proto3.util.setEnumType(AlertType, "model.v1.AlertType", [
  { no: 0, name: "UNKNOWN_ALERT_TYPE" },
  { no: 1, name: "TRANSACTION" },
  { no: 2, name: "BLOCK" },
  { no: 3, name: "PRIVATE" },
  { no: 4, name: "COMBINATION" },
  { no: 5, name: "API" },
]);

/**
 * @generated from message model.v1.TrackingTimestamps
 */
export class TrackingTimestamps extends Message<TrackingTimestamps> {
  /**
   * @generated from field: string block = 1;
   */
  block = "";

  /**
   * @generated from field: string feed = 2;
   */
  feed = "";

  /**
   * @generated from field: string botRequest = 3;
   */
  botRequest = "";

  /**
   * @generated from field: string botResponse = 4;
   */
  botResponse = "";

  /**
   * @generated from field: string sourceAlert = 5;
   */
  sourceAlert = "";

  constructor(data?: PartialMessage<TrackingTimestamps>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.TrackingTimestamps";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "feed", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "botRequest", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "botResponse", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "sourceAlert", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TrackingTimestamps {
    return new TrackingTimestamps().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TrackingTimestamps {
    return new TrackingTimestamps().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TrackingTimestamps {
    return new TrackingTimestamps().fromJsonString(jsonString, options);
  }

  static equals(a: TrackingTimestamps | PlainMessage<TrackingTimestamps> | undefined, b: TrackingTimestamps | PlainMessage<TrackingTimestamps> | undefined): boolean {
    return proto3.util.equals(TrackingTimestamps, a, b);
  }
}

/**
 * @generated from message model.v1.AgentInfo
 */
export class AgentInfo extends Message<AgentInfo> {
  /**
   * @generated from field: string image = 1;
   */
  image = "";

  /**
   * @generated from field: string imageHash = 2;
   */
  imageHash = "";

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  /**
   * @generated from field: bool isTest = 4;
   */
  isTest = false;

  /**
   * @generated from field: string manifest = 5;
   */
  manifest = "";

  constructor(data?: PartialMessage<AgentInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.AgentInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "imageHash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "isTest", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "manifest", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentInfo {
    return new AgentInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentInfo {
    return new AgentInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentInfo {
    return new AgentInfo().fromJsonString(jsonString, options);
  }

  static equals(a: AgentInfo | PlainMessage<AgentInfo> | undefined, b: AgentInfo | PlainMessage<AgentInfo> | undefined): boolean {
    return proto3.util.equals(AgentInfo, a, b);
  }
}

/**
 * @generated from message model.v1.ScannerInfo
 */
export class ScannerInfo extends Message<ScannerInfo> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<ScannerInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.ScannerInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScannerInfo {
    return new ScannerInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScannerInfo {
    return new ScannerInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScannerInfo {
    return new ScannerInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ScannerInfo | PlainMessage<ScannerInfo> | undefined, b: ScannerInfo | PlainMessage<ScannerInfo> | undefined): boolean {
    return proto3.util.equals(ScannerInfo, a, b);
  }
}

/**
 * @generated from message model.v1.AlertResponse
 */
export class AlertResponse extends Message<AlertResponse> {
  /**
   * @generated from field: repeated model.v1.SignedAlert alerts = 1;
   */
  alerts: SignedAlert[] = [];

  /**
   * @generated from field: string nextPageToken = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<AlertResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.AlertResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alerts", kind: "message", T: SignedAlert, repeated: true },
    { no: 2, name: "nextPageToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertResponse {
    return new AlertResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertResponse {
    return new AlertResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertResponse {
    return new AlertResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AlertResponse | PlainMessage<AlertResponse> | undefined, b: AlertResponse | PlainMessage<AlertResponse> | undefined): boolean {
    return proto3.util.equals(AlertResponse, a, b);
  }
}

/**
 * @generated from message model.v1.Signature
 */
export class Signature extends Message<Signature> {
  /**
   * @generated from field: string signature = 1;
   */
  signature = "";

  /**
   * @generated from field: string algorithm = 2;
   */
  algorithm = "";

  /**
   * @generated from field: string signer = 3;
   */
  signer = "";

  constructor(data?: PartialMessage<Signature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Signature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signature {
    return new Signature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJsonString(jsonString, options);
  }

  static equals(a: Signature | PlainMessage<Signature> | undefined, b: Signature | PlainMessage<Signature> | undefined): boolean {
    return proto3.util.equals(Signature, a, b);
  }
}

/**
 * @generated from message model.v1.BloomFilter
 */
export class BloomFilter extends Message<BloomFilter> {
  /**
   * @generated from field: string k = 1;
   */
  k = "";

  /**
   * @generated from field: string m = 2;
   */
  m = "";

  /**
   * @generated from field: string bitset = 3;
   */
  bitset = "";

  /**
   * @generated from field: uint32 itemCount = 4;
   */
  itemCount = 0;

  constructor(data?: PartialMessage<BloomFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.BloomFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "k", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "m", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "bitset", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "itemCount", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BloomFilter {
    return new BloomFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BloomFilter {
    return new BloomFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BloomFilter {
    return new BloomFilter().fromJsonString(jsonString, options);
  }

  static equals(a: BloomFilter | PlainMessage<BloomFilter> | undefined, b: BloomFilter | PlainMessage<BloomFilter> | undefined): boolean {
    return proto3.util.equals(BloomFilter, a, b);
  }
}

/**
 * @generated from message model.v1.Alert
 */
export class Alert extends Message<Alert> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: model.v1.AlertType type = 2;
   */
  type = AlertType.UNKNOWN_ALERT_TYPE;

  /**
   * @generated from field: model.v1.Finding finding = 3;
   */
  finding?: Finding;

  /**
   * @generated from field: string timestamp = 4;
   */
  timestamp = "";

  /**
   * @generated from field: map<string, string> metadata = 5;
   */
  metadata: { [key: string]: string } = {};

  /**
   * @generated from field: model.v1.AgentInfo agent = 6;
   */
  agent?: AgentInfo;

  /**
   * @generated from field: map<string, string> tags = 7;
   */
  tags: { [key: string]: string } = {};

  /**
   * @generated from field: model.v1.ScannerInfo scanner = 8;
   */
  scanner?: ScannerInfo;

  /**
   * @generated from field: model.v1.TrackingTimestamps timestamps = 9;
   */
  timestamps?: TrackingTimestamps;

  /**
   * @generated from field: bool truncated = 10;
   */
  truncated = false;

  /**
   * @generated from field: model.v1.BloomFilter addressBloomFilter = 11;
   */
  addressBloomFilter?: BloomFilter;

  constructor(data?: PartialMessage<Alert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Alert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(AlertType) },
    { no: 3, name: "finding", kind: "message", T: Finding },
    { no: 4, name: "timestamp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "agent", kind: "message", T: AgentInfo },
    { no: 7, name: "tags", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 8, name: "scanner", kind: "message", T: ScannerInfo },
    { no: 9, name: "timestamps", kind: "message", T: TrackingTimestamps },
    { no: 10, name: "truncated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "addressBloomFilter", kind: "message", T: BloomFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Alert {
    return new Alert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Alert {
    return new Alert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Alert {
    return new Alert().fromJsonString(jsonString, options);
  }

  static equals(a: Alert | PlainMessage<Alert> | undefined, b: Alert | PlainMessage<Alert> | undefined): boolean {
    return proto3.util.equals(Alert, a, b);
  }
}

/**
 * @generated from message model.v1.SignedAlert
 */
export class SignedAlert extends Message<SignedAlert> {
  /**
   * @generated from field: model.v1.Alert alert = 1;
   */
  alert?: Alert;

  /**
   * @generated from field: model.v1.Signature signature = 2;
   */
  signature?: Signature;

  /**
   * @generated from field: string chainId = 3;
   */
  chainId = "";

  /**
   * @generated from field: string blockNumber = 4;
   */
  blockNumber = "";

  /**
   * @generated from field: string publishedWithTx = 5;
   */
  publishedWithTx = "";

  constructor(data?: PartialMessage<SignedAlert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.SignedAlert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alert", kind: "message", T: Alert },
    { no: 2, name: "signature", kind: "message", T: Signature },
    { no: 3, name: "chainId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "blockNumber", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "publishedWithTx", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignedAlert {
    return new SignedAlert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignedAlert {
    return new SignedAlert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignedAlert {
    return new SignedAlert().fromJsonString(jsonString, options);
  }

  static equals(a: SignedAlert | PlainMessage<SignedAlert> | undefined, b: SignedAlert | PlainMessage<SignedAlert> | undefined): boolean {
    return proto3.util.equals(SignedAlert, a, b);
  }
}

/**
 * @generated from message model.v1.Label
 */
export class Label extends Message<Label> {
  /**
   * @generated from field: model.v1.Label.EntityType entityType = 1;
   */
  entityType = Label_EntityType.UNKNOWN_ENTITY_TYPE;

  /**
   * @generated from field: string entity = 2;
   */
  entity = "";

  /**
   * @generated from field: float confidence = 4;
   */
  confidence = 0;

  /**
   * @generated from field: bool remove = 6;
   */
  remove = false;

  /**
   * @generated from field: string label = 7;
   */
  label = "";

  /**
   * @generated from field: repeated string metadata = 8;
   */
  metadata: string[] = [];

  /**
   * @generated from field: string uniqueKey = 9;
   */
  uniqueKey = "";

  /**
   * @generated from field: repeated float embedding = 10;
   */
  embedding: number[] = [];

  constructor(data?: PartialMessage<Label>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Label";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entityType", kind: "enum", T: proto3.getEnumType(Label_EntityType) },
    { no: 2, name: "entity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "confidence", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 6, name: "remove", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "metadata", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "uniqueKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "embedding", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Label {
    return new Label().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Label {
    return new Label().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Label {
    return new Label().fromJsonString(jsonString, options);
  }

  static equals(a: Label | PlainMessage<Label> | undefined, b: Label | PlainMessage<Label> | undefined): boolean {
    return proto3.util.equals(Label, a, b);
  }
}

/**
 * @generated from enum model.v1.Label.EntityType
 */
export enum Label_EntityType {
  /**
   * @generated from enum value: UNKNOWN_ENTITY_TYPE = 0;
   */
  UNKNOWN_ENTITY_TYPE = 0,

  /**
   * @generated from enum value: ADDRESS = 1;
   */
  ADDRESS = 1,

  /**
   * @generated from enum value: TRANSACTION = 2;
   */
  TRANSACTION = 2,

  /**
   * @generated from enum value: BLOCK = 3;
   */
  BLOCK = 3,

  /**
   * @generated from enum value: URL = 4;
   */
  URL = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Label_EntityType)
proto3.util.setEnumType(Label_EntityType, "model.v1.Label.EntityType", [
  { no: 0, name: "UNKNOWN_ENTITY_TYPE" },
  { no: 1, name: "ADDRESS" },
  { no: 2, name: "TRANSACTION" },
  { no: 3, name: "BLOCK" },
  { no: 4, name: "URL" },
]);

/**
 * @generated from message model.v1.Source
 */
export class Source extends Message<Source> {
  /**
   * @generated from field: repeated model.v1.Source.TransactionSource transactions = 1;
   */
  transactions: Source_TransactionSource[] = [];

  /**
   * @generated from field: repeated model.v1.Source.BlockSource blocks = 2;
   */
  blocks: Source_BlockSource[] = [];

  /**
   * @generated from field: repeated model.v1.Source.URLSource urls = 3;
   */
  urls: Source_URLSource[] = [];

  /**
   * @generated from field: repeated model.v1.Source.ChainSource chains = 4;
   */
  chains: Source_ChainSource[] = [];

  /**
   * @generated from field: repeated model.v1.Source.AlertSource alerts = 5;
   */
  alerts: Source_AlertSource[] = [];

  /**
   * @generated from field: repeated model.v1.Source.CustomSource customSources = 6;
   */
  customSources: Source_CustomSource[] = [];

  constructor(data?: PartialMessage<Source>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Source";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactions", kind: "message", T: Source_TransactionSource, repeated: true },
    { no: 2, name: "blocks", kind: "message", T: Source_BlockSource, repeated: true },
    { no: 3, name: "urls", kind: "message", T: Source_URLSource, repeated: true },
    { no: 4, name: "chains", kind: "message", T: Source_ChainSource, repeated: true },
    { no: 5, name: "alerts", kind: "message", T: Source_AlertSource, repeated: true },
    { no: 6, name: "customSources", kind: "message", T: Source_CustomSource, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source {
    return new Source().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJsonString(jsonString, options);
  }

  static equals(a: Source | PlainMessage<Source> | undefined, b: Source | PlainMessage<Source> | undefined): boolean {
    return proto3.util.equals(Source, a, b);
  }
}

/**
 * @generated from message model.v1.Source.TransactionSource
 */
export class Source_TransactionSource extends Message<Source_TransactionSource> {
  /**
   * @generated from field: uint64 chainId = 1;
   */
  chainId = protoInt64.zero;

  /**
   * @generated from field: string hash = 2;
   */
  hash = "";

  constructor(data?: PartialMessage<Source_TransactionSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Source.TransactionSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chainId", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source_TransactionSource {
    return new Source_TransactionSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source_TransactionSource {
    return new Source_TransactionSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source_TransactionSource {
    return new Source_TransactionSource().fromJsonString(jsonString, options);
  }

  static equals(a: Source_TransactionSource | PlainMessage<Source_TransactionSource> | undefined, b: Source_TransactionSource | PlainMessage<Source_TransactionSource> | undefined): boolean {
    return proto3.util.equals(Source_TransactionSource, a, b);
  }
}

/**
 * @generated from message model.v1.Source.BlockSource
 */
export class Source_BlockSource extends Message<Source_BlockSource> {
  /**
   * @generated from field: uint64 chainId = 1;
   */
  chainId = protoInt64.zero;

  /**
   * @generated from field: string hash = 2;
   */
  hash = "";

  /**
   * @generated from field: uint64 number = 3;
   */
  number = protoInt64.zero;

  constructor(data?: PartialMessage<Source_BlockSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Source.BlockSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chainId", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source_BlockSource {
    return new Source_BlockSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source_BlockSource {
    return new Source_BlockSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source_BlockSource {
    return new Source_BlockSource().fromJsonString(jsonString, options);
  }

  static equals(a: Source_BlockSource | PlainMessage<Source_BlockSource> | undefined, b: Source_BlockSource | PlainMessage<Source_BlockSource> | undefined): boolean {
    return proto3.util.equals(Source_BlockSource, a, b);
  }
}

/**
 * @generated from message model.v1.Source.URLSource
 */
export class Source_URLSource extends Message<Source_URLSource> {
  /**
   * @generated from field: string url = 1;
   */
  url = "";

  constructor(data?: PartialMessage<Source_URLSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Source.URLSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source_URLSource {
    return new Source_URLSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source_URLSource {
    return new Source_URLSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source_URLSource {
    return new Source_URLSource().fromJsonString(jsonString, options);
  }

  static equals(a: Source_URLSource | PlainMessage<Source_URLSource> | undefined, b: Source_URLSource | PlainMessage<Source_URLSource> | undefined): boolean {
    return proto3.util.equals(Source_URLSource, a, b);
  }
}

/**
 * @generated from message model.v1.Source.ChainSource
 */
export class Source_ChainSource extends Message<Source_ChainSource> {
  /**
   * @generated from field: uint64 chainId = 1;
   */
  chainId = protoInt64.zero;

  constructor(data?: PartialMessage<Source_ChainSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Source.ChainSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chainId", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source_ChainSource {
    return new Source_ChainSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source_ChainSource {
    return new Source_ChainSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source_ChainSource {
    return new Source_ChainSource().fromJsonString(jsonString, options);
  }

  static equals(a: Source_ChainSource | PlainMessage<Source_ChainSource> | undefined, b: Source_ChainSource | PlainMessage<Source_ChainSource> | undefined): boolean {
    return proto3.util.equals(Source_ChainSource, a, b);
  }
}

/**
 * @generated from message model.v1.Source.AlertSource
 */
export class Source_AlertSource extends Message<Source_AlertSource> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<Source_AlertSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Source.AlertSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source_AlertSource {
    return new Source_AlertSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source_AlertSource {
    return new Source_AlertSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source_AlertSource {
    return new Source_AlertSource().fromJsonString(jsonString, options);
  }

  static equals(a: Source_AlertSource | PlainMessage<Source_AlertSource> | undefined, b: Source_AlertSource | PlainMessage<Source_AlertSource> | undefined): boolean {
    return proto3.util.equals(Source_AlertSource, a, b);
  }
}

/**
 * @generated from message model.v1.Source.CustomSource
 */
export class Source_CustomSource extends Message<Source_CustomSource> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<Source_CustomSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Source.CustomSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source_CustomSource {
    return new Source_CustomSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source_CustomSource {
    return new Source_CustomSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source_CustomSource {
    return new Source_CustomSource().fromJsonString(jsonString, options);
  }

  static equals(a: Source_CustomSource | PlainMessage<Source_CustomSource> | undefined, b: Source_CustomSource | PlainMessage<Source_CustomSource> | undefined): boolean {
    return proto3.util.equals(Source_CustomSource, a, b);
  }
}

/**
 * @generated from message model.v1.Finding
 */
export class Finding extends Message<Finding> {
  /**
   * @generated from field: string protocol = 1;
   */
  protocol = "";

  /**
   * @generated from field: model.v1.Finding.Severity severity = 2;
   */
  severity = Finding_Severity.UNKNOWN;

  /**
   * @generated from field: map<string, string> metadata = 3;
   */
  metadata: { [key: string]: string } = {};

  /**
   * @generated from field: model.v1.Finding.FindingType type = 4;
   */
  type = Finding_FindingType.UNKNOWN_TYPE;

  /**
   * @generated from field: string alertId = 5;
   */
  alertId = "";

  /**
   * @generated from field: string name = 6;
   */
  name = "";

  /**
   * @generated from field: string description = 7;
   */
  description = "";

  /**
   * @generated from field: bool private = 9;
   */
  private = false;

  /**
   * @generated from field: repeated string addresses = 10;
   */
  addresses: string[] = [];

  /**
   * @generated from field: map<string, double> indicators = 11;
   */
  indicators: { [key: string]: number } = {};

  /**
   * @generated from field: repeated model.v1.Label labels = 12;
   */
  labels: Label[] = [];

  /**
   * @generated from field: repeated string relatedAlerts = 13;
   */
  relatedAlerts: string[] = [];

  /**
   * @generated from field: string uniqueKey = 14;
   */
  uniqueKey = "";

  /**
   * @generated from field: model.v1.Source source = 15;
   */
  source?: Source;

  /**
   * @generated from field: string timestamp = 16;
   */
  timestamp = "";

  constructor(data?: PartialMessage<Finding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.Finding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "severity", kind: "enum", T: proto3.getEnumType(Finding_Severity) },
    { no: 3, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "type", kind: "enum", T: proto3.getEnumType(Finding_FindingType) },
    { no: 5, name: "alertId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "private", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "indicators", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 1 /* ScalarType.DOUBLE */} },
    { no: 12, name: "labels", kind: "message", T: Label, repeated: true },
    { no: 13, name: "relatedAlerts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "uniqueKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "source", kind: "message", T: Source },
    { no: 16, name: "timestamp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Finding {
    return new Finding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Finding {
    return new Finding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Finding {
    return new Finding().fromJsonString(jsonString, options);
  }

  static equals(a: Finding | PlainMessage<Finding> | undefined, b: Finding | PlainMessage<Finding> | undefined): boolean {
    return proto3.util.equals(Finding, a, b);
  }
}

/**
 * @generated from enum model.v1.Finding.Severity
 */
export enum Finding_Severity {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: INFO = 1;
   */
  INFO = 1,

  /**
   * @generated from enum value: LOW = 2;
   */
  LOW = 2,

  /**
   * @generated from enum value: MEDIUM = 3;
   */
  MEDIUM = 3,

  /**
   * @generated from enum value: HIGH = 4;
   */
  HIGH = 4,

  /**
   * @generated from enum value: CRITICAL = 5;
   */
  CRITICAL = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Finding_Severity)
proto3.util.setEnumType(Finding_Severity, "model.v1.Finding.Severity", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "INFO" },
  { no: 2, name: "LOW" },
  { no: 3, name: "MEDIUM" },
  { no: 4, name: "HIGH" },
  { no: 5, name: "CRITICAL" },
]);

/**
 * @generated from enum model.v1.Finding.FindingType
 */
export enum Finding_FindingType {
  /**
   * @generated from enum value: UNKNOWN_TYPE = 0;
   */
  UNKNOWN_TYPE = 0,

  /**
   * @generated from enum value: EXPLOIT = 1;
   */
  EXPLOIT = 1,

  /**
   * @generated from enum value: SUSPICIOUS = 2;
   */
  SUSPICIOUS = 2,

  /**
   * @generated from enum value: DEGRADED = 3;
   */
  DEGRADED = 3,

  /**
   * @generated from enum value: INFORMATION = 4;
   */
  INFORMATION = 4,

  /**
   * @generated from enum value: SCAM = 5;
   */
  SCAM = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Finding_FindingType)
proto3.util.setEnumType(Finding_FindingType, "model.v1.Finding.FindingType", [
  { no: 0, name: "UNKNOWN_TYPE" },
  { no: 1, name: "EXPLOIT" },
  { no: 2, name: "SUSPICIOUS" },
  { no: 3, name: "DEGRADED" },
  { no: 4, name: "INFORMATION" },
  { no: 5, name: "SCAM" },
]);

/**
 * @generated from message model.v1.APIAlert
 */
export class APIAlert extends Message<APIAlert> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: model.v1.AlertType type = 2;
   */
  type = AlertType.UNKNOWN_ALERT_TYPE;

  /**
   * @generated from field: model.v1.Finding finding = 3;
   */
  finding?: Finding;

  /**
   * @generated from field: model.v1.APIAlert.APIAlertAgent agent = 4;
   */
  agent?: APIAlert_APIAlertAgent;

  /**
   * @generated from field: string timestamp = 5;
   */
  timestamp = "";

  constructor(data?: PartialMessage<APIAlert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.APIAlert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(AlertType) },
    { no: 3, name: "finding", kind: "message", T: Finding },
    { no: 4, name: "agent", kind: "message", T: APIAlert_APIAlertAgent },
    { no: 5, name: "timestamp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): APIAlert {
    return new APIAlert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): APIAlert {
    return new APIAlert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): APIAlert {
    return new APIAlert().fromJsonString(jsonString, options);
  }

  static equals(a: APIAlert | PlainMessage<APIAlert> | undefined, b: APIAlert | PlainMessage<APIAlert> | undefined): boolean {
    return proto3.util.equals(APIAlert, a, b);
  }
}

/**
 * @generated from message model.v1.APIAlert.APIAlertAgent
 */
export class APIAlert_APIAlertAgent extends Message<APIAlert_APIAlertAgent> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<APIAlert_APIAlertAgent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "model.v1.APIAlert.APIAlertAgent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): APIAlert_APIAlertAgent {
    return new APIAlert_APIAlertAgent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): APIAlert_APIAlertAgent {
    return new APIAlert_APIAlertAgent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): APIAlert_APIAlertAgent {
    return new APIAlert_APIAlertAgent().fromJsonString(jsonString, options);
  }

  static equals(a: APIAlert_APIAlertAgent | PlainMessage<APIAlert_APIAlertAgent> | undefined, b: APIAlert_APIAlertAgent | PlainMessage<APIAlert_APIAlertAgent> | undefined): boolean {
    return proto3.util.equals(APIAlert_APIAlertAgent, a, b);
  }
}

