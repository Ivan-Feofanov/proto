// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: model/v1/alert.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { Finding } from "./finding";
import Long = require("long");

export const protobufPackage = "model.v1";

export enum AlertType {
  UNKNOWN_ALERT_TYPE = 0,
  TRANSACTION = 1,
  BLOCK = 2,
  PRIVATE = 3,
  COMBINATION = 4,
  API = 5,
  UNRECOGNIZED = -1,
}

export function alertTypeFromJSON(object: any): AlertType {
  switch (object) {
    case 0:
    case "UNKNOWN_ALERT_TYPE":
      return AlertType.UNKNOWN_ALERT_TYPE;
    case 1:
    case "TRANSACTION":
      return AlertType.TRANSACTION;
    case 2:
    case "BLOCK":
      return AlertType.BLOCK;
    case 3:
    case "PRIVATE":
      return AlertType.PRIVATE;
    case 4:
    case "COMBINATION":
      return AlertType.COMBINATION;
    case 5:
    case "API":
      return AlertType.API;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlertType.UNRECOGNIZED;
  }
}

export function alertTypeToJSON(object: AlertType): string {
  switch (object) {
    case AlertType.UNKNOWN_ALERT_TYPE:
      return "UNKNOWN_ALERT_TYPE";
    case AlertType.TRANSACTION:
      return "TRANSACTION";
    case AlertType.BLOCK:
      return "BLOCK";
    case AlertType.PRIVATE:
      return "PRIVATE";
    case AlertType.COMBINATION:
      return "COMBINATION";
    case AlertType.API:
      return "API";
    case AlertType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TrackingTimestamps {
  block: string;
  feed: string;
  botRequest: string;
  botResponse: string;
  sourceAlert: string;
}

export interface AgentInfo {
  image: string;
  imageHash: string;
  id: string;
  isTest: boolean;
  manifest: string;
}

export interface ScannerInfo {
  address: string;
}

export interface AlertResponse {
  alerts: SignedAlert[];
  nextPageToken: string;
}

export interface Signature {
  signature: string;
  algorithm: string;
  signer: string;
}

export interface BloomFilter {
  k: string;
  m: string;
  bitset: string;
  itemCount: number;
}

export interface Alert {
  id: string;
  type: AlertType;
  finding: Finding | undefined;
  timestamp: string;
  metadata: { [key: string]: string };
  agent: AgentInfo | undefined;
  tags: { [key: string]: string };
  scanner: ScannerInfo | undefined;
  timestamps: TrackingTimestamps | undefined;
  truncated: boolean;
  addressBloomFilter: BloomFilter | undefined;
}

export interface Alert_MetadataEntry {
  key: string;
  value: string;
}

export interface Alert_TagsEntry {
  key: string;
  value: string;
}

export interface SignedAlert {
  alert: Alert | undefined;
  signature: Signature | undefined;
  chainId: string;
  blockNumber: string;
  publishedWithTx: string;
}

export interface Label {
  entityType: Label_EntityType;
  entity: string;
  confidence: number;
  remove: boolean;
  label: string;
  metadata: string[];
  uniqueKey: string;
  embedding: number[];
}

export enum Label_EntityType {
  UNKNOWN_ENTITY_TYPE = 0,
  ADDRESS = 1,
  TRANSACTION = 2,
  BLOCK = 3,
  URL = 4,
  UNRECOGNIZED = -1,
}

export function label_EntityTypeFromJSON(object: any): Label_EntityType {
  switch (object) {
    case 0:
    case "UNKNOWN_ENTITY_TYPE":
      return Label_EntityType.UNKNOWN_ENTITY_TYPE;
    case 1:
    case "ADDRESS":
      return Label_EntityType.ADDRESS;
    case 2:
    case "TRANSACTION":
      return Label_EntityType.TRANSACTION;
    case 3:
    case "BLOCK":
      return Label_EntityType.BLOCK;
    case 4:
    case "URL":
      return Label_EntityType.URL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Label_EntityType.UNRECOGNIZED;
  }
}

export function label_EntityTypeToJSON(object: Label_EntityType): string {
  switch (object) {
    case Label_EntityType.UNKNOWN_ENTITY_TYPE:
      return "UNKNOWN_ENTITY_TYPE";
    case Label_EntityType.ADDRESS:
      return "ADDRESS";
    case Label_EntityType.TRANSACTION:
      return "TRANSACTION";
    case Label_EntityType.BLOCK:
      return "BLOCK";
    case Label_EntityType.URL:
      return "URL";
    case Label_EntityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Source {
  transactions: Source_TransactionSource[];
  blocks: Source_BlockSource[];
  urls: Source_URLSource[];
  chains: Source_ChainSource[];
  alerts: Source_AlertSource[];
  customSources: Source_CustomSource[];
}

export interface Source_TransactionSource {
  chainId: number;
  hash: string;
}

export interface Source_BlockSource {
  chainId: number;
  hash: string;
  number: number;
}

export interface Source_URLSource {
  url: string;
}

export interface Source_ChainSource {
  chainId: number;
}

export interface Source_AlertSource {
  id: string;
}

export interface Source_CustomSource {
  name: string;
  value: string;
}

export interface APIAlert {
  id: string;
  type: AlertType;
  finding: Finding | undefined;
  agent: APIAlert_APIAlertAgent | undefined;
  timestamp: string;
}

export interface APIAlert_APIAlertAgent {
  id: string;
}

function createBaseTrackingTimestamps(): TrackingTimestamps {
  return { block: "", feed: "", botRequest: "", botResponse: "", sourceAlert: "" };
}

export const TrackingTimestamps = {
  encode(message: TrackingTimestamps, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.block !== "") {
      writer.uint32(10).string(message.block);
    }
    if (message.feed !== "") {
      writer.uint32(18).string(message.feed);
    }
    if (message.botRequest !== "") {
      writer.uint32(26).string(message.botRequest);
    }
    if (message.botResponse !== "") {
      writer.uint32(34).string(message.botResponse);
    }
    if (message.sourceAlert !== "") {
      writer.uint32(42).string(message.sourceAlert);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TrackingTimestamps {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackingTimestamps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.block = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feed = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.botRequest = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.botResponse = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sourceAlert = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackingTimestamps {
    return {
      block: isSet(object.block) ? globalThis.String(object.block) : "",
      feed: isSet(object.feed) ? globalThis.String(object.feed) : "",
      botRequest: isSet(object.botRequest) ? globalThis.String(object.botRequest) : "",
      botResponse: isSet(object.botResponse) ? globalThis.String(object.botResponse) : "",
      sourceAlert: isSet(object.sourceAlert) ? globalThis.String(object.sourceAlert) : "",
    };
  },

  toJSON(message: TrackingTimestamps): unknown {
    const obj: any = {};
    if (message.block !== "") {
      obj.block = message.block;
    }
    if (message.feed !== "") {
      obj.feed = message.feed;
    }
    if (message.botRequest !== "") {
      obj.botRequest = message.botRequest;
    }
    if (message.botResponse !== "") {
      obj.botResponse = message.botResponse;
    }
    if (message.sourceAlert !== "") {
      obj.sourceAlert = message.sourceAlert;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackingTimestamps>, I>>(base?: I): TrackingTimestamps {
    return TrackingTimestamps.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackingTimestamps>, I>>(object: I): TrackingTimestamps {
    const message = createBaseTrackingTimestamps();
    message.block = object.block ?? "";
    message.feed = object.feed ?? "";
    message.botRequest = object.botRequest ?? "";
    message.botResponse = object.botResponse ?? "";
    message.sourceAlert = object.sourceAlert ?? "";
    return message;
  },
};

function createBaseAgentInfo(): AgentInfo {
  return { image: "", imageHash: "", id: "", isTest: false, manifest: "" };
}

export const AgentInfo = {
  encode(message: AgentInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.image !== "") {
      writer.uint32(10).string(message.image);
    }
    if (message.imageHash !== "") {
      writer.uint32(18).string(message.imageHash);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.isTest !== false) {
      writer.uint32(32).bool(message.isTest);
    }
    if (message.manifest !== "") {
      writer.uint32(42).string(message.manifest);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.image = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isTest = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.manifest = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentInfo {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      imageHash: isSet(object.imageHash) ? globalThis.String(object.imageHash) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isTest: isSet(object.isTest) ? globalThis.Boolean(object.isTest) : false,
      manifest: isSet(object.manifest) ? globalThis.String(object.manifest) : "",
    };
  },

  toJSON(message: AgentInfo): unknown {
    const obj: any = {};
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.imageHash !== "") {
      obj.imageHash = message.imageHash;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isTest !== false) {
      obj.isTest = message.isTest;
    }
    if (message.manifest !== "") {
      obj.manifest = message.manifest;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentInfo>, I>>(base?: I): AgentInfo {
    return AgentInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentInfo>, I>>(object: I): AgentInfo {
    const message = createBaseAgentInfo();
    message.image = object.image ?? "";
    message.imageHash = object.imageHash ?? "";
    message.id = object.id ?? "";
    message.isTest = object.isTest ?? false;
    message.manifest = object.manifest ?? "";
    return message;
  },
};

function createBaseScannerInfo(): ScannerInfo {
  return { address: "" };
}

export const ScannerInfo = {
  encode(message: ScannerInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScannerInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScannerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScannerInfo {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: ScannerInfo): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScannerInfo>, I>>(base?: I): ScannerInfo {
    return ScannerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScannerInfo>, I>>(object: I): ScannerInfo {
    const message = createBaseScannerInfo();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseAlertResponse(): AlertResponse {
  return { alerts: [], nextPageToken: "" };
}

export const AlertResponse = {
  encode(message: AlertResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.alerts) {
      SignedAlert.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AlertResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alerts.push(SignedAlert.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertResponse {
    return {
      alerts: globalThis.Array.isArray(object?.alerts) ? object.alerts.map((e: any) => SignedAlert.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: AlertResponse): unknown {
    const obj: any = {};
    if (message.alerts?.length) {
      obj.alerts = message.alerts.map((e) => SignedAlert.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlertResponse>, I>>(base?: I): AlertResponse {
    return AlertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlertResponse>, I>>(object: I): AlertResponse {
    const message = createBaseAlertResponse();
    message.alerts = object.alerts?.map((e) => SignedAlert.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSignature(): Signature {
  return { signature: "", algorithm: "", signer: "" };
}

export const Signature = {
  encode(message: Signature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.algorithm !== "") {
      writer.uint32(18).string(message.algorithm);
    }
    if (message.signer !== "") {
      writer.uint32(26).string(message.signer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Signature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signature>, I>>(base?: I): Signature {
    return Signature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signature>, I>>(object: I): Signature {
    const message = createBaseSignature();
    message.signature = object.signature ?? "";
    message.algorithm = object.algorithm ?? "";
    message.signer = object.signer ?? "";
    return message;
  },
};

function createBaseBloomFilter(): BloomFilter {
  return { k: "", m: "", bitset: "", itemCount: 0 };
}

export const BloomFilter = {
  encode(message: BloomFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.k !== "") {
      writer.uint32(10).string(message.k);
    }
    if (message.m !== "") {
      writer.uint32(18).string(message.m);
    }
    if (message.bitset !== "") {
      writer.uint32(26).string(message.bitset);
    }
    if (message.itemCount !== 0) {
      writer.uint32(32).uint32(message.itemCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BloomFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBloomFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.k = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.m = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bitset = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.itemCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BloomFilter {
    return {
      k: isSet(object.k) ? globalThis.String(object.k) : "",
      m: isSet(object.m) ? globalThis.String(object.m) : "",
      bitset: isSet(object.bitset) ? globalThis.String(object.bitset) : "",
      itemCount: isSet(object.itemCount) ? globalThis.Number(object.itemCount) : 0,
    };
  },

  toJSON(message: BloomFilter): unknown {
    const obj: any = {};
    if (message.k !== "") {
      obj.k = message.k;
    }
    if (message.m !== "") {
      obj.m = message.m;
    }
    if (message.bitset !== "") {
      obj.bitset = message.bitset;
    }
    if (message.itemCount !== 0) {
      obj.itemCount = Math.round(message.itemCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BloomFilter>, I>>(base?: I): BloomFilter {
    return BloomFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BloomFilter>, I>>(object: I): BloomFilter {
    const message = createBaseBloomFilter();
    message.k = object.k ?? "";
    message.m = object.m ?? "";
    message.bitset = object.bitset ?? "";
    message.itemCount = object.itemCount ?? 0;
    return message;
  },
};

function createBaseAlert(): Alert {
  return {
    id: "",
    type: 0,
    finding: undefined,
    timestamp: "",
    metadata: {},
    agent: undefined,
    tags: {},
    scanner: undefined,
    timestamps: undefined,
    truncated: false,
    addressBloomFilter: undefined,
  };
}

export const Alert = {
  encode(message: Alert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.finding !== undefined) {
      Finding.encode(message.finding, writer.uint32(26).fork()).ldelim();
    }
    if (message.timestamp !== "") {
      writer.uint32(34).string(message.timestamp);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Alert_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.agent !== undefined) {
      AgentInfo.encode(message.agent, writer.uint32(50).fork()).ldelim();
    }
    Object.entries(message.tags).forEach(([key, value]) => {
      Alert_TagsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    if (message.scanner !== undefined) {
      ScannerInfo.encode(message.scanner, writer.uint32(66).fork()).ldelim();
    }
    if (message.timestamps !== undefined) {
      TrackingTimestamps.encode(message.timestamps, writer.uint32(74).fork()).ldelim();
    }
    if (message.truncated !== false) {
      writer.uint32(80).bool(message.truncated);
    }
    if (message.addressBloomFilter !== undefined) {
      BloomFilter.encode(message.addressBloomFilter, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Alert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.finding = Finding.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Alert_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.agent = AgentInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Alert_TagsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.tags[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.scanner = ScannerInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.timestamps = TrackingTimestamps.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.truncated = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.addressBloomFilter = BloomFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Alert {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? alertTypeFromJSON(object.type) : 0,
      finding: isSet(object.finding) ? Finding.fromJSON(object.finding) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      agent: isSet(object.agent) ? AgentInfo.fromJSON(object.agent) : undefined,
      tags: isObject(object.tags)
        ? Object.entries(object.tags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      scanner: isSet(object.scanner) ? ScannerInfo.fromJSON(object.scanner) : undefined,
      timestamps: isSet(object.timestamps) ? TrackingTimestamps.fromJSON(object.timestamps) : undefined,
      truncated: isSet(object.truncated) ? globalThis.Boolean(object.truncated) : false,
      addressBloomFilter: isSet(object.addressBloomFilter)
        ? BloomFilter.fromJSON(object.addressBloomFilter)
        : undefined,
    };
  },

  toJSON(message: Alert): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = alertTypeToJSON(message.type);
    }
    if (message.finding !== undefined) {
      obj.finding = Finding.toJSON(message.finding);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.agent !== undefined) {
      obj.agent = AgentInfo.toJSON(message.agent);
    }
    if (message.tags) {
      const entries = Object.entries(message.tags);
      if (entries.length > 0) {
        obj.tags = {};
        entries.forEach(([k, v]) => {
          obj.tags[k] = v;
        });
      }
    }
    if (message.scanner !== undefined) {
      obj.scanner = ScannerInfo.toJSON(message.scanner);
    }
    if (message.timestamps !== undefined) {
      obj.timestamps = TrackingTimestamps.toJSON(message.timestamps);
    }
    if (message.truncated !== false) {
      obj.truncated = message.truncated;
    }
    if (message.addressBloomFilter !== undefined) {
      obj.addressBloomFilter = BloomFilter.toJSON(message.addressBloomFilter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Alert>, I>>(base?: I): Alert {
    return Alert.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Alert>, I>>(object: I): Alert {
    const message = createBaseAlert();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.finding = (object.finding !== undefined && object.finding !== null)
      ? Finding.fromPartial(object.finding)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.agent = (object.agent !== undefined && object.agent !== null)
      ? AgentInfo.fromPartial(object.agent)
      : undefined;
    message.tags = Object.entries(object.tags ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.scanner = (object.scanner !== undefined && object.scanner !== null)
      ? ScannerInfo.fromPartial(object.scanner)
      : undefined;
    message.timestamps = (object.timestamps !== undefined && object.timestamps !== null)
      ? TrackingTimestamps.fromPartial(object.timestamps)
      : undefined;
    message.truncated = object.truncated ?? false;
    message.addressBloomFilter = (object.addressBloomFilter !== undefined && object.addressBloomFilter !== null)
      ? BloomFilter.fromPartial(object.addressBloomFilter)
      : undefined;
    return message;
  },
};

function createBaseAlert_MetadataEntry(): Alert_MetadataEntry {
  return { key: "", value: "" };
}

export const Alert_MetadataEntry = {
  encode(message: Alert_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Alert_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlert_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Alert_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Alert_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Alert_MetadataEntry>, I>>(base?: I): Alert_MetadataEntry {
    return Alert_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Alert_MetadataEntry>, I>>(object: I): Alert_MetadataEntry {
    const message = createBaseAlert_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAlert_TagsEntry(): Alert_TagsEntry {
  return { key: "", value: "" };
}

export const Alert_TagsEntry = {
  encode(message: Alert_TagsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Alert_TagsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlert_TagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Alert_TagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Alert_TagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Alert_TagsEntry>, I>>(base?: I): Alert_TagsEntry {
    return Alert_TagsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Alert_TagsEntry>, I>>(object: I): Alert_TagsEntry {
    const message = createBaseAlert_TagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSignedAlert(): SignedAlert {
  return { alert: undefined, signature: undefined, chainId: "", blockNumber: "", publishedWithTx: "" };
}

export const SignedAlert = {
  encode(message: SignedAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.alert !== undefined) {
      Alert.encode(message.alert, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature !== undefined) {
      Signature.encode(message.signature, writer.uint32(18).fork()).ldelim();
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    if (message.blockNumber !== "") {
      writer.uint32(34).string(message.blockNumber);
    }
    if (message.publishedWithTx !== "") {
      writer.uint32(42).string(message.publishedWithTx);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alert = Alert.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = Signature.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockNumber = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.publishedWithTx = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedAlert {
    return {
      alert: isSet(object.alert) ? Alert.fromJSON(object.alert) : undefined,
      signature: isSet(object.signature) ? Signature.fromJSON(object.signature) : undefined,
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      blockNumber: isSet(object.blockNumber) ? globalThis.String(object.blockNumber) : "",
      publishedWithTx: isSet(object.publishedWithTx) ? globalThis.String(object.publishedWithTx) : "",
    };
  },

  toJSON(message: SignedAlert): unknown {
    const obj: any = {};
    if (message.alert !== undefined) {
      obj.alert = Alert.toJSON(message.alert);
    }
    if (message.signature !== undefined) {
      obj.signature = Signature.toJSON(message.signature);
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.blockNumber !== "") {
      obj.blockNumber = message.blockNumber;
    }
    if (message.publishedWithTx !== "") {
      obj.publishedWithTx = message.publishedWithTx;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignedAlert>, I>>(base?: I): SignedAlert {
    return SignedAlert.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignedAlert>, I>>(object: I): SignedAlert {
    const message = createBaseSignedAlert();
    message.alert = (object.alert !== undefined && object.alert !== null) ? Alert.fromPartial(object.alert) : undefined;
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? Signature.fromPartial(object.signature)
      : undefined;
    message.chainId = object.chainId ?? "";
    message.blockNumber = object.blockNumber ?? "";
    message.publishedWithTx = object.publishedWithTx ?? "";
    return message;
  },
};

function createBaseLabel(): Label {
  return {
    entityType: 0,
    entity: "",
    confidence: 0,
    remove: false,
    label: "",
    metadata: [],
    uniqueKey: "",
    embedding: [],
  };
}

export const Label = {
  encode(message: Label, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entityType !== 0) {
      writer.uint32(8).int32(message.entityType);
    }
    if (message.entity !== "") {
      writer.uint32(18).string(message.entity);
    }
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    if (message.remove !== false) {
      writer.uint32(48).bool(message.remove);
    }
    if (message.label !== "") {
      writer.uint32(58).string(message.label);
    }
    for (const v of message.metadata) {
      writer.uint32(66).string(v!);
    }
    if (message.uniqueKey !== "") {
      writer.uint32(74).string(message.uniqueKey);
    }
    writer.uint32(82).fork();
    for (const v of message.embedding) {
      writer.float(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Label {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.entityType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entity = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.remove = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.label = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.metadata.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.uniqueKey = reader.string();
          continue;
        case 10:
          if (tag === 85) {
            message.embedding.push(reader.float());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.embedding.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Label {
    return {
      entityType: isSet(object.entityType) ? label_EntityTypeFromJSON(object.entityType) : 0,
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      remove: isSet(object.remove) ? globalThis.Boolean(object.remove) : false,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      metadata: globalThis.Array.isArray(object?.metadata) ? object.metadata.map((e: any) => globalThis.String(e)) : [],
      uniqueKey: isSet(object.uniqueKey) ? globalThis.String(object.uniqueKey) : "",
      embedding: globalThis.Array.isArray(object?.embedding)
        ? object.embedding.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Label): unknown {
    const obj: any = {};
    if (message.entityType !== 0) {
      obj.entityType = label_EntityTypeToJSON(message.entityType);
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.remove !== false) {
      obj.remove = message.remove;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata;
    }
    if (message.uniqueKey !== "") {
      obj.uniqueKey = message.uniqueKey;
    }
    if (message.embedding?.length) {
      obj.embedding = message.embedding;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Label>, I>>(base?: I): Label {
    return Label.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Label>, I>>(object: I): Label {
    const message = createBaseLabel();
    message.entityType = object.entityType ?? 0;
    message.entity = object.entity ?? "";
    message.confidence = object.confidence ?? 0;
    message.remove = object.remove ?? false;
    message.label = object.label ?? "";
    message.metadata = object.metadata?.map((e) => e) || [];
    message.uniqueKey = object.uniqueKey ?? "";
    message.embedding = object.embedding?.map((e) => e) || [];
    return message;
  },
};

function createBaseSource(): Source {
  return { transactions: [], blocks: [], urls: [], chains: [], alerts: [], customSources: [] };
}

export const Source = {
  encode(message: Source, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      Source_TransactionSource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.blocks) {
      Source_BlockSource.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.urls) {
      Source_URLSource.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.chains) {
      Source_ChainSource.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.alerts) {
      Source_AlertSource.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.customSources) {
      Source_CustomSource.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Source {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(Source_TransactionSource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blocks.push(Source_BlockSource.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.urls.push(Source_URLSource.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chains.push(Source_ChainSource.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.alerts.push(Source_AlertSource.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customSources.push(Source_CustomSource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Source_TransactionSource.fromJSON(e))
        : [],
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => Source_BlockSource.fromJSON(e))
        : [],
      urls: globalThis.Array.isArray(object?.urls) ? object.urls.map((e: any) => Source_URLSource.fromJSON(e)) : [],
      chains: globalThis.Array.isArray(object?.chains)
        ? object.chains.map((e: any) => Source_ChainSource.fromJSON(e))
        : [],
      alerts: globalThis.Array.isArray(object?.alerts)
        ? object.alerts.map((e: any) => Source_AlertSource.fromJSON(e))
        : [],
      customSources: globalThis.Array.isArray(object?.customSources)
        ? object.customSources.map((e: any) => Source_CustomSource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Source): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Source_TransactionSource.toJSON(e));
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Source_BlockSource.toJSON(e));
    }
    if (message.urls?.length) {
      obj.urls = message.urls.map((e) => Source_URLSource.toJSON(e));
    }
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => Source_ChainSource.toJSON(e));
    }
    if (message.alerts?.length) {
      obj.alerts = message.alerts.map((e) => Source_AlertSource.toJSON(e));
    }
    if (message.customSources?.length) {
      obj.customSources = message.customSources.map((e) => Source_CustomSource.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source>, I>>(base?: I): Source {
    return Source.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source>, I>>(object: I): Source {
    const message = createBaseSource();
    message.transactions = object.transactions?.map((e) => Source_TransactionSource.fromPartial(e)) || [];
    message.blocks = object.blocks?.map((e) => Source_BlockSource.fromPartial(e)) || [];
    message.urls = object.urls?.map((e) => Source_URLSource.fromPartial(e)) || [];
    message.chains = object.chains?.map((e) => Source_ChainSource.fromPartial(e)) || [];
    message.alerts = object.alerts?.map((e) => Source_AlertSource.fromPartial(e)) || [];
    message.customSources = object.customSources?.map((e) => Source_CustomSource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSource_TransactionSource(): Source_TransactionSource {
  return { chainId: 0, hash: "" };
}

export const Source_TransactionSource = {
  encode(message: Source_TransactionSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== 0) {
      writer.uint32(8).uint64(message.chainId);
    }
    if (message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Source_TransactionSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource_TransactionSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source_TransactionSource {
    return {
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
    };
  },

  toJSON(message: Source_TransactionSource): unknown {
    const obj: any = {};
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source_TransactionSource>, I>>(base?: I): Source_TransactionSource {
    return Source_TransactionSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source_TransactionSource>, I>>(object: I): Source_TransactionSource {
    const message = createBaseSource_TransactionSource();
    message.chainId = object.chainId ?? 0;
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseSource_BlockSource(): Source_BlockSource {
  return { chainId: 0, hash: "", number: 0 };
}

export const Source_BlockSource = {
  encode(message: Source_BlockSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== 0) {
      writer.uint32(8).uint64(message.chainId);
    }
    if (message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.number !== 0) {
      writer.uint32(24).uint64(message.number);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Source_BlockSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource_BlockSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.number = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source_BlockSource {
    return {
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
    };
  },

  toJSON(message: Source_BlockSource): unknown {
    const obj: any = {};
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source_BlockSource>, I>>(base?: I): Source_BlockSource {
    return Source_BlockSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source_BlockSource>, I>>(object: I): Source_BlockSource {
    const message = createBaseSource_BlockSource();
    message.chainId = object.chainId ?? 0;
    message.hash = object.hash ?? "";
    message.number = object.number ?? 0;
    return message;
  },
};

function createBaseSource_URLSource(): Source_URLSource {
  return { url: "" };
}

export const Source_URLSource = {
  encode(message: Source_URLSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Source_URLSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource_URLSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source_URLSource {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: Source_URLSource): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source_URLSource>, I>>(base?: I): Source_URLSource {
    return Source_URLSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source_URLSource>, I>>(object: I): Source_URLSource {
    const message = createBaseSource_URLSource();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseSource_ChainSource(): Source_ChainSource {
  return { chainId: 0 };
}

export const Source_ChainSource = {
  encode(message: Source_ChainSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== 0) {
      writer.uint32(8).uint64(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Source_ChainSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource_ChainSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source_ChainSource {
    return { chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0 };
  },

  toJSON(message: Source_ChainSource): unknown {
    const obj: any = {};
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source_ChainSource>, I>>(base?: I): Source_ChainSource {
    return Source_ChainSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source_ChainSource>, I>>(object: I): Source_ChainSource {
    const message = createBaseSource_ChainSource();
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseSource_AlertSource(): Source_AlertSource {
  return { id: "" };
}

export const Source_AlertSource = {
  encode(message: Source_AlertSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Source_AlertSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource_AlertSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source_AlertSource {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: Source_AlertSource): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source_AlertSource>, I>>(base?: I): Source_AlertSource {
    return Source_AlertSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source_AlertSource>, I>>(object: I): Source_AlertSource {
    const message = createBaseSource_AlertSource();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseSource_CustomSource(): Source_CustomSource {
  return { name: "", value: "" };
}

export const Source_CustomSource = {
  encode(message: Source_CustomSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Source_CustomSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource_CustomSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source_CustomSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Source_CustomSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source_CustomSource>, I>>(base?: I): Source_CustomSource {
    return Source_CustomSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source_CustomSource>, I>>(object: I): Source_CustomSource {
    const message = createBaseSource_CustomSource();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAPIAlert(): APIAlert {
  return { id: "", type: 0, finding: undefined, agent: undefined, timestamp: "" };
}

export const APIAlert = {
  encode(message: APIAlert, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.finding !== undefined) {
      Finding.encode(message.finding, writer.uint32(26).fork()).ldelim();
    }
    if (message.agent !== undefined) {
      APIAlert_APIAlertAgent.encode(message.agent, writer.uint32(34).fork()).ldelim();
    }
    if (message.timestamp !== "") {
      writer.uint32(42).string(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): APIAlert {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAPIAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.finding = Finding.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.agent = APIAlert_APIAlertAgent.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timestamp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): APIAlert {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? alertTypeFromJSON(object.type) : 0,
      finding: isSet(object.finding) ? Finding.fromJSON(object.finding) : undefined,
      agent: isSet(object.agent) ? APIAlert_APIAlertAgent.fromJSON(object.agent) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: APIAlert): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = alertTypeToJSON(message.type);
    }
    if (message.finding !== undefined) {
      obj.finding = Finding.toJSON(message.finding);
    }
    if (message.agent !== undefined) {
      obj.agent = APIAlert_APIAlertAgent.toJSON(message.agent);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<APIAlert>, I>>(base?: I): APIAlert {
    return APIAlert.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<APIAlert>, I>>(object: I): APIAlert {
    const message = createBaseAPIAlert();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.finding = (object.finding !== undefined && object.finding !== null)
      ? Finding.fromPartial(object.finding)
      : undefined;
    message.agent = (object.agent !== undefined && object.agent !== null)
      ? APIAlert_APIAlertAgent.fromPartial(object.agent)
      : undefined;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseAPIAlert_APIAlertAgent(): APIAlert_APIAlertAgent {
  return { id: "" };
}

export const APIAlert_APIAlertAgent = {
  encode(message: APIAlert_APIAlertAgent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): APIAlert_APIAlertAgent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAPIAlert_APIAlertAgent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): APIAlert_APIAlertAgent {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: APIAlert_APIAlertAgent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<APIAlert_APIAlertAgent>, I>>(base?: I): APIAlert_APIAlertAgent {
    return APIAlert_APIAlertAgent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<APIAlert_APIAlertAgent>, I>>(object: I): APIAlert_APIAlertAgent {
    const message = createBaseAPIAlert_APIAlertAgent();
    message.id = object.id ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
